(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3 = global.d3 || {})));
}(this, function (exports) { 'use strict';

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function radial () {
    var radius = 200,
        smoothing = 0.2,
        distortion = 3,
        center = [0, 0],
        inverseSmoothing,
        smoothingCoefficient,
        sarkarCoefficient,
        distortionCoefficient;

    function fisheye(point) {
      var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (smoothing === 1 || distortion === 0) return [].concat(_toConsumableArray(point), [1]);

      var _point = _slicedToArray(point, 2),
          x = _point[0],
          y = _point[1];

      var _center = center,
          _center2 = _slicedToArray(_center, 2),
          centerX = _center2[0],
          centerY = _center2[1];

      var deltaX = x - centerX;
      var deltaY = y - centerY;

      if (Math.abs(deltaX) > radius || Math.abs(deltaY) > radius) {
        return [].concat(_toConsumableArray(point), [1]);
      }

      var distanceFromCenter = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));

      if (Math.abs(distanceFromCenter) > radius) {
        return [].concat(_toConsumableArray(point), [1]);
      }

      if (distanceFromCenter == 0) {
        return [].concat(_toConsumableArray(point), [distortion]);
      }

      var normalizedDistance = distanceFromCenter / radius;
      var fisheyeDistance = smoothedFisheye(normalizedDistance, inverse);
      var cos = deltaX / distanceFromCenter;
      var sin = deltaY / distanceFromCenter;
      return [centerX + cos * radius * fisheyeDistance, centerY + sin * radius * fisheyeDistance, fisheyeDistance / normalizedDistance];
    }

    function smoothedFisheye(x) {
      var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (inverse) {
        if (x < inverseSmoothing) {
          return x / (sarkarCoefficient * distortionCoefficient + sarkarCoefficient - distortionCoefficient * x);
        } else {
          return (smoothingCoefficient + Math.sqrt(2 * smoothingCoefficient * x - 2 * smoothingCoefficient + 1) - 1) / smoothingCoefficient;
        }
      }

      if (x <= 1 - smoothing) {
        return sarkarCoefficient * x * (distortionCoefficient + 1) / (distortionCoefficient * x + 1);
      } else {
        return smoothingCoefficient * Math.pow(x - 1, 2) / 2 + x;
      }
    }

    function recalculate() {
      var _solveForConstants = solveForConstants();

      var _solveForConstants2 = _slicedToArray(_solveForConstants, 4);

      smoothingCoefficient = _solveForConstants2[0];
      sarkarCoefficient = _solveForConstants2[1];
      distortionCoefficient = _solveForConstants2[2];
      inverseSmoothing = _solveForConstants2[3];
      return fisheye;
    }

    function solveForConstants() {
      if (smoothing === 0 || smoothing === 1) {
        return [0, 1, distortion, smoothing];
      }

      var xw = 1 - smoothing;
      var d = distortion;
      var smoothingCoefficient = 2 * xw * (d * xw - Math.sqrt(Math.pow(d, 2) * Math.pow(xw, 2) + d * Math.pow(xw, 2) + d + 1) + 1) / (Math.pow(xw, 3) - 3 * Math.pow(xw, 2) + 3 * xw - 1);
      var sarkarCoefficient = xw * (Math.pow(d, 2) * xw + d * Math.pow(xw, 2) + 2 * d * xw - d * Math.sqrt(Math.pow(d, 2) * Math.pow(xw, 2) + d * Math.pow(xw, 2) + d + 1) - d + Math.pow(xw, 2) + xw - Math.sqrt(Math.pow(d, 2) * Math.pow(xw, 2) + d * Math.pow(xw, 2) + d + 1) - 1) / (2 * d * Math.pow(xw, 2) - d * xw - d + Math.pow(xw, 3) + Math.pow(xw, 2) - 2 * xw);
      var distortionCoefficient = (d * xw + Math.sqrt((d + 1) * (d * Math.pow(xw, 2) + 1)) - 1) / (xw * (xw + 1));
      return [smoothingCoefficient, sarkarCoefficient, distortionCoefficient, smoothingCoefficient * Math.pow(xw - 1, 2) / 2 + xw];
    }

    fisheye.radius = function (_) {
      if (!arguments.length) return radius;
      radius = +_;
      return recalculate();
    };

    fisheye.smoothing = function (_) {
      if (!arguments.length) return smoothing;
      smoothing = +_;
      return recalculate();
    };

    fisheye.distortion = function (_) {
      if (!arguments.length) return distortion;
      distortion = +_;
      return recalculate();
    };

    fisheye.center = function (_) {
      if (!arguments.length) return center;
      center = _;
      return fisheye;
    };

    fisheye.focus = fisheye.center;
    fisheye.smoothingRatio = fisheye.smoothing;
    fisheye.fisheyeRadial = fisheye;

    fisheye.fisheyeFunction = function (x) {
      if (x <= 0 || x >= 1) return x;
      return smoothedFisheye(x);
    };

    return recalculate();
  }

  exports.radial = radial;
  exports.circular = radial;

  Object.defineProperty(exports, '__esModule', { value: true });

}));